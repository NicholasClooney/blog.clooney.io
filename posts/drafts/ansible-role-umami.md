---
draft: true

title: "Portable Umami with Docker Compose + Ansible (production‑ready)"
date: 2025-10-02
eleventyNavigation:
  key: ansible-role-umami
---

## TL;DR

* You **don’t need to clone the Umami repo** to deploy with Docker; a **`docker-compose.yml`** is enough.
* For production: generate a **strong `APP_SECRET`**, use a **strong Postgres password**, **don’t expose the DB**, and **bind Umami to localhost** behind a reverse proxy with TLS.
* Wrap all of this into a **portable Ansible role** that renders a `.env` and a hardened `docker-compose.yml`, then runs `docker compose` idempotently.

---

## Why Umami’s docs can feel confusing at first

Umami provides two common paths:

1. **Install from source** (Node + pnpm): you create a database yourself and put a `DATABASE_URL` in `.env`.
2. **Use Docker**: `docker-compose.yml` defines both services (app + DB), and you wire the `DATABASE_URL` via environment variables.

If you choose Docker, you **don’t need** the whole GitHub repo. You just need a Compose file (and optionally an `.env`).

> **About default creds (`umami`/`umami`)**: examples use these for convenience because the Postgres service is **not exposed** externally. It’s fine for demos, but for production you should change them.

---

## A production‑hardened `docker-compose.yml`

**Design goals:**

* Postgres runs without a host port mapping (inaccessible from the Internet).
* Umami binds to **`127.0.0.1:3000`** so only your reverse proxy can reach it locally.
* Secrets and configuration live in a `.env`.
* Healthchecks, log rotation, and conservative restart policy.

```yaml
version: "3.8"

networks:
  umami-net:
    driver: bridge

volumes:
  umami-db-data:

services:
  db:
    image: postgres:16-alpine
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      TZ: ${TZ}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U \"$${POSTGRES_USER}\" -d \"$${POSTGRES_DB}\""]
      interval: 5s
      timeout: 5s
      retries: 10
    volumes:
      - umami-db-data:/var/lib/postgresql/data
    networks:
      - umami-net
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

  umami:
    image: ghcr.io/umami-software/umami:postgresql-latest
    restart: unless-stopped
    depends_on:
      db:
        condition: service_healthy
    ports:
      - "127.0.0.1:${UMAMI_PORT:-3000}:3000"
    environment:
      DATABASE_TYPE: postgresql
      DATABASE_URL: ${DATABASE_URL}
      APP_SECRET: ${APP_SECRET}
      HOSTNAME: "0.0.0.0"
      PORT: "3000"
      TZ: ${TZ}
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://localhost:3000/api/heartbeat || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10
    networks:
      - umami-net
    security_opt:
      - no-new-privileges:true
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
```

**Example `.env`** (values will be generated by Ansible below):

```dotenv
TZ=Europe/London
POSTGRES_DB=umami
POSTGRES_USER=umami
POSTGRES_PASSWORD=REDACTED_STRONG_PASSWORD
UMAMI_PORT=3000
APP_SECRET=REDACTED_LONG_RANDOM
DATABASE_URL=postgresql://umami:REDACTED_STRONG_PASSWORD@db:5432/umami
```

> Generate secrets locally if you’re doing it by hand:
>
> ```bash
> openssl rand -hex 64        # APP_SECRET
> openssl rand -base64 32     # POSTGRES_PASSWORD
> ```

---

## Portable Ansible role: design & code

**Goal:** one role that works on any host with Docker/Compose already installed. The role should:

* create `/opt/umami/` (config home),
* generate strong secrets if none are provided,
* template `.env` and `docker-compose.yml`,
* `docker compose up -d` idempotently,
* restart on config changes.

### Suggested role layout

```
ansible-role-umami/
├─ defaults/
│  └─ main.yml
├─ handlers/
│  └─ main.yml
├─ meta/
│  └─ main.yml
├─ tasks/
│  └─ main.yml
├─ templates/
│  ├─ docker-compose.yml.j2
│  └─ env.j2
└─ README.md
```

### `defaults/main.yml`

```yaml
---
umami_base_dir: /opt/umami
umami_timezone: Europe/London
umami_image: ghcr.io/umami-software/umami:postgresql-latest
umami_postgres_image: postgres:16-alpine
umami_listen_port: 3000
umami_bind_address: 127.0.0.1
umami_db_name: umami
umami_db_user: umami
umami_db_password: ""   # auto-generate if empty
umami_app_secret: ""    # auto-generate if empty
umami_compose_project_name: umami
umami_compose_pull: true
umami_compose_recreate: auto    # auto|always|never
```

### `tasks/main.yml`


{% raw %}
```yaml
---
- name: Ensure base directory exists
  file:
    path: "{{ umami_base_dir }}"
    state: directory
    owner: root
    group: root
    mode: "0755"

- name: Generate DB password if needed
  set_fact:
    umami_db_password: "{{ lookup('password', umami_base_dir ~ '/.db_password chars=ascii_letters,digits length=32') }}"
  when: umami_db_password | length == 0

- name: Generate app secret if needed
  set_fact:
    umami_app_secret: "{{ lookup('password', umami_base_dir ~ '/.app_secret chars=hexdigits length=64') }}"
  when: umami_app_secret | length == 0

- name: Render .env
  template:
    src: env.j2
    dest: "{{ umami_base_dir }}/.env"
    owner: root
    group: root
    mode: "0640"
  notify: Restart umami stack

- name: Render docker-compose.yml
  template:
    src: docker-compose.yml.j2
    dest: "{{ umami_base_dir }}/docker-compose.yml"
    owner: root
    group: root
    mode: "0644"
  notify: Restart umami stack

- name: Bring up Umami stack
  community.docker.docker_compose_v2:
    project_src: "{{ umami_base_dir }}"
    project_name: "{{ umami_compose_project_name }}"
    state: present
    pull: "{{ umami_compose_pull }}"
    recreate: "{{ umami_compose_recreate }}"
  register: compose_result

- name: Show compose changes (debug)
  debug:
    var: compose_result
  when: compose_result is defined
```
{% endraw %}

### `handlers/main.yml`

```yaml
---
- name: Restart umami stack
  community.docker.docker_compose_v2:
    project_src: "{{ umami_base_dir }}"
    project_name: "{{ umami_compose_project_name }}"
    state: restarted
```

### `templates/env.j2`

```jinja2
# Managed by Ansible — do not edit by hand.
TZ={{ umami_timezone }}
POSTGRES_DB={{ umami_db_name }}
POSTGRES_USER={{ umami_db_user }}
POSTGRES_PASSWORD={{ umami_db_password }}
UMAMI_PORT={{ umami_listen_port }}
APP_SECRET={{ umami_app_secret }}
DATABASE_URL=postgresql://{{ umami_db_user }}:{{ umami_db_password }}@db:5432/{{ umami_db_name }}
```

### `templates/docker-compose.yml.j2`

```jinja2
# Managed by Ansible — do not edit by hand.
version: "3.8"

networks:
  umami-net:
    driver: bridge

volumes:
  umami-db-data:

services:
  db:
    image: {{ umami_postgres_image }}
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      TZ: ${TZ}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U \"$${POSTGRES_USER}\" -d \"$${POSTGRES_DB}\""]
      interval: 5s
      timeout: 5s
      retries: 10
    volumes:
      - umami-db-data:/var/lib/postgresql/data
    networks:
      - umami-net
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

  umami:
    image: {{ umami_image }}
    restart: unless-stopped
    depends_on:
      db:
        condition: service_healthy
    ports:
      - "{{ umami_bind_address }}:${UMAMI_PORT:-{{ umami_listen_port }}}:3000"
    environment:
      DATABASE_TYPE: postgresql
      DATABASE_URL: ${DATABASE_URL}
      APP_SECRET: ${APP_SECRET}
      HOSTNAME: "0.0.0.0"
      PORT: "3000"
      TZ: ${TZ}
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://localhost:3000/api/heartbeat || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10
    networks:
      - umami-net
    security_opt:
      - no-new-privileges:true
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
```

### How to call the role

```yaml
- hosts: umami_hosts
  become: true
  roles:
    - role: umami
      vars:
        umami_timezone: Europe/London
        umami_bind_address: 127.0.0.1
        umami_listen_port: 3000
        # Optional: pin images or provide your own secrets
        # umami_image: ghcr.io/umami-software/umami:postgresql-2.10.0
        # umami_db_password: "super-strong-pass"
        # umami_app_secret: "64-char-hex"
```

---

## Standalone role vs. Collection layout

* **Standalone role repo** (`ansible-role-umami`): role sits at repo root. Easiest to publish and consume via `ansible-galaxy role install`.
* **Ansible Collection** (`your_ns.umami`): role lives under `roles/umami/` with optional plugins. Use if you plan multiple roles or custom modules/filters.

**Collection skeleton** (abridged):

```
your_ns/umami/
├─ galaxy.yml
├─ roles/
│  └─ umami/
│     ├─ defaults/ …
│     └─ templates/ …
└─ plugins/ (optional)
```

---

## Reverse proxy (Caddy example)

Terminate TLS at Caddy and forward to Umami on loopback:

```caddyfile
umami.example.com {
  encode zstd gzip
  tls you@example.com
  reverse_proxy 127.0.0.1:3000
}
```

> Nginx works equally well; just proxy to `http://127.0.0.1:3000` and enable HTTP/2 + TLS.

---

## Operations cheat‑sheet

* **Start/Update:** `docker compose pull && docker compose up -d`
* **Logs:** `docker compose logs -f umami`
* **DB shell:** `docker compose exec db psql -U "$POSTGRES_USER" -d "$POSTGRES_DB"`
* **Backup:** `docker compose exec db pg_dump -U "$POSTGRES_USER" "$POSTGRES_DB" > umami_$(date +%F).sql`
* **Restore:** `docker compose exec -T db psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" < backup.sql`
* **Health:** visit `/api/heartbeat` via the proxy or check container health status.

Pin image tags for stricter change control and schedule regular updates.

---

## Common pitfalls & fixes

* **Port already in use**: change `UMAMI_PORT` or stop whatever is using `3000` locally.
* **`APP_SECRET` too short/weak**: use a long hex string (e.g., `openssl rand -hex 64`).
* **DB auth failures**: ensure `POSTGRES_PASSWORD` matches inside both Postgres and `DATABASE_URL`.
* **Accidentally exposed Postgres**: make sure there’s **no** `ports:` mapping on the `db` service.
* **No HTTPS**: put a reverse proxy in front; do **not** expose `:3000` to the Internet directly in production.

---

## Closing thoughts

The clean separation between **container config** and **secrets** (via `.env`), plus **idempotent automation** with Ansible, gives you a portable Umami deployment you can drop onto any Docker‑ready host. Start minimal, keep the DB private, put TLS at the edge, and you’re in solid shape.

If you want, we can extend the role with optional **Caddy/Nginx provisioning**, backups via **cron/systemd timers**, and Molecule tests for CI.
